class StyleSystem : EventHandler
{
	int score;
	int deprecation_tick;
	int reward_tick;
	string current_weapon;
	int consecutive_uses;
    const SCORE_THRESHOLD = 25000;

	override void WorldThingDamaged(WorldEvent e)
	{
		bool is_attackable_target = e.thing.bIsMonster || e.thing.GetClassName() == "Doox";

		if (!cvar.FindCvar("StyleSystem").GetBool())
			return;

		if (e.thing && e.thing is "PlayerPawn") {
			DeductStyleScore(e);
		}
		else if (e.thing && is_attackable_target && !(e.damagesource && e.damagesource.bIsMonster) && !(e.inflictor && e.inflictor.bIsMonster)) {
			UpdateStyleScore(e);
		}
	}

    override void NetworkProcess(ConsoleEvent e)
    {
        if (e.Name == "taunt") {
            int score_bonus = SCORE_THRESHOLD / 2;
            int rank = cvar.FindCvar("StyleRank").GetInt() + 1;

            score_bonus = score_bonus / rank;

            score_bonus = max(score_bonus, 1);

            score += score_bonus;
            CapStyleScore();
            CallACS("Taunt");
        }
    }


	override void WorldTick()
	{
		if (!cvar.FindCvar("StyleSystem").GetBool())
			return;

		UpdateStyleRank();
		UpdateWeapon();
		DeprecateStyleScore();
	}

	private void UpdateStyleScore(WorldEvent e)
	{
		/* Player object */
		PlayerPawn player = players[consoleplayer].mo;

		/* Consecutive uses */
		let ReadyWeapon = player.player.ReadyWeapon;
		let PlayerIsResponsible = e.damagesource && e.damagesource is "PlayerPawn";
		if (ReadyWeapon && ReadyWeapon.GetClassName() == current_weapon && PlayerIsResponsible) {
			consecutive_uses++;
		}

		/* Initialisation */
		int stylerank = cvar.FindCvar("StyleRank").GetInt();
		int scorebonus;

		/* Dealing damage */
        int accumulation_factor = 75;
		if (PlayerIsResponsible) {
			scorebonus += e.damage * accumulation_factor;
		}
		else {
			if (stylerank >= 1) {
				scorebonus += e.damage * (accumulation_factor / 6);
			}
			else {
				return;
			}
		}

		/* Using different weapon */
		if (ReadyWeapon.GetClassName() != current_weapon) {
			scorebonus *= 2;
		}

		/* Height bonus */
		if (!player.player.onground) {
			scorebonus *= 1.3;
		}

		/* Enemy mid-air bonus */
		if (e.thing.Pos.Z > e.thing.GetZAt()) {
			scorebonus *= 2;
		}

		/* Add case for Offhand Attack */
		bool offhand_attack_used = e.DamageType == "SonicKick" ||
								   e.DamageType == "ShadowMelee" ||
                                   e.DamageType == "Spear" ||
								   e.DamageType == "Piko" ||
								   e.DamageType == "SonicPunch";

		/* Clamp score bonus */
		int minimum_score = 525 + GetScoreBonusCap() / 100;
		int maximum_score = GetScoreBonusCap();
		scorebonus = clamp(scorebonus, minimum_score, maximum_score);

        /* Calculate staleness */
        int staleness_factor = 64 + e.damage;
        int staleness = staleness_factor * consecutive_uses;
        staleness *= cvar.FindCvar("StaleMultiplier").GetFloat();
        staleness = clamp(staleness, 0, scorebonus);

		// Apply staleness, unless an Offhand Attack was used
		if (!offhand_attack_used) {
			scorebonus -= staleness;
		}

		/* Total up score */
		score += scorebonus;

        CapStyleScore();

		/* It isn't here, but the player can also gain Style
		   Points by parrying attacks.

		   Go and see Sonic.zsc and Amy.zsc for that code. */
	}

    private void CapStyleScore()
    {
        int max_score = SCORE_THRESHOLD * 9;
        score = clamp(score, 0, max_score);
    }

	private void DeductStyleScore(WorldEvent e)
	{
		int penalty = SCORE_THRESHOLD;

        bool does_damage_more_than_once =
            e.Inflictor is "ProjectileShotgunner" ||
            e.Inflictor is "ProjectileChaingunner" ||
            e.Inflictor is "SLL_Cyberdemon" ||
            e.Inflictor is "SLL_SpiderMastermind";

        if (e.Inflictor != null && does_damage_more_than_once) {
            penalty /= 25;
        }

		score -= penalty;
	}

	private int GetScoreBonusCap()
	{
		PlayerPawn player = players[consoleplayer].mo;
		int stylerank = cvar.FindCvar("StyleRank").GetInt();
		int cap;
		switch (stylerank) {
			case 0: // E
			case 1: // D
			case 2: // C
				cap = 15000;
				break;
			case 3: // B
			case 4: // A
				cap = 10000;
				break;
			case 5: // S
			case 6: // SS
			case 7: // SSS
			case 8: // U
				cap = 5000;
				break;
		}

		return cap;
	}

    private void DeprecateStyleScore()
    {
        PlayerPawn player = players[consoleplayer].mo;
        int stylerank = cvar.FindCvar("StyleRank").GetInt();

        int start_value = 48;
        int step = 128;
        int deprecation = start_value + stylerank * step;

        if (deprecation_tick > 2) {
            deprecation_tick = 0;
            score -= deprecation;
        }
    }

    private void UpdateStyleRank()
    {
        PlayerPawn player = players[consoleplayer].mo;
        if (score < 0 || player.health <= 0) score = 0;
        cvar.FindCvar("StyleScore").SetInt(score);

        deprecation_tick++;
        reward_tick++;

        // Set your Style Rank
        int rank_index = score / SCORE_THRESHOLD;
        rank_index = clamp(rank_index, 0, 8);
        cvar.FindCvar("StyleRank").SetInt(rank_index);

        // Obtain Style Rank to sync up
        int style_rank = cvar.FindCvar("StyleRank").GetInt();

        if (style_rank >= 3) {
            GiveStyleRewards(player, style_rank);
        }
    }

	private void GiveStyleRewards(Actor player, int style_rank)
	{
		bool is_transformed = player.CountInv("PowerSuper") || player.CountInv("PowerHyper");
		bool rewards_enabled = cvar.FindCvar("StyleBonuses").GetBool();

		if (is_transformed && rewards_enabled) {
			return;
		}

		int delay;
        int multiplier;

		switch (style_rank) {
			case 8:
			case 7:
				delay = 1;
                multiplier = 2;
				break;
			case 6:
				delay = 1;
                multiplier = 1;
				break;
			case 5:
				delay = 2;
                multiplier = 2;
				break;
			case 4:
				delay = 2;
                multiplier = 1;
				break;
			case 3:
			default:
				delay = 3;
                multiplier = 1;
				break;
		}

		if (reward_tick % delay == 0) {
			player.A_GiveInventory("ChaosEnergy", multiplier);
		}
	}

	private void UpdateWeapon()
	{
		PlayerPawn player = players[consoleplayer].mo;

		/* If the player's weapon has previously been
		   switched, reset the amount of consecutive
		   uses and reset their current weapon. */
		if (player.player.ReadyWeapon && player.player.ReadyWeapon.GetClassName() != current_weapon) {
			consecutive_uses = 0;
			current_weapon = player.player.ReadyWeapon.GetClassName();
		}
	}
}